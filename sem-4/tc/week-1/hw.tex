\documentclass{article}

\usepackage[dark,showauthor]{../../../classes/dim}

\begin{document}
    \header{Theory of Computation}{Week one}

    \begin{tasks}
        \begin{enumerate}
        \item \begin{problem}
            Find a deterministic finite automaton accepting all strings in \(\{0, 1\}^*\) such
            that every 0 has a 1 immediately to its right.
        \end{problem}
        
        Such automaton would look like this:
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,double=background]
                \node[state,initial,accepting,color=tcum] (z_0) {$z_0$};
                \node[state] (z_1) [right=of z_0] {$z_1$};
                \node[state] (z_2) [right=of z_1] {$z_2$};

                \path[->] 
                    (z_0)   edge [bend left] node {0} (z_1)
                            edge [loop above] node {1} (z_0)
                    (z_1)   edge [bend left] node {1} (z_0)
                            edge [] node {0} (z_2)
                    (z_2)   edge [loop above] node {0,1} (z_2)
                ;
            \end{tikzpicture}
        \end{figure}
        \item Since language is regularg if and only if it can be represented
              by a DFA, the complement can also be represented by just switching
              the accepting states for non-accepting and vice versa.
        \item For a language consisting of a single string, building a regular 
              expression is straight forward, just concatenate the symbols in
              the neccessary order. Unifying finite amount of regular expressions
              is similarly straight forward. So if a language has finite strings,
              building a regular expression is always possible, therefore every
              finite language is regular.
        \item Assuming \(A = \{1\}\) the DFA is:
              \begin{figure}[H]
                \centering
                \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,double=background, scale=0.8, every node/.style={transform shape}]
                    \node[state,initial,accepting,color=tcum] (z_0) {$z_0$};
                    \node[state,right=of z_0] (z_1) {$z_1$};
                    \node[state] (z_2) [right=of z_1] {$z_2$};
                    \node[state,accepting,color=tcum] (z_3) [right=of z_2] {$z_3$};
                    \node[state] (z_4) [right=of z_3] {$z_4$};
                    \node[state,accepting,color=tcum] (z_5) [right=of z_4] {$z_5$};
                    \node[state,accepting,color=tcum] (z_6) [right=of z_5] {$z_6$};
                    \node[state] (z_7) [right=of z_6] {$z_7$};
                    \node[state] (z_8) [below=of z_7] {$z_8$};
                    \node[state,accepting,color=tcum] (z_9) [left=of z_8] {$z_9$};
                    \node[state,accepting,color=tcum] (z_10) [left=of z_9] {$z_{10}$};
                    \node[state] (z_11) [left=of z_10] {$z_{11}$};
                    \node[state,accepting,color=tcum] (z_12) [left=of z_11] {$z_{12}$};
                    \node[state] (z_13) [left=of z_12] {$z_{13}$};
                    \node[state] (z_14) [left=of z_13] {$z_{14}$};

                    \path[->] 
                        (z_0)   edge [] node {1} (z_1)
                        (z_1)   edge [] node {1} (z_2)
                        (z_2)   edge [] node {1} (z_3)
                        (z_3)   edge [] node {1} (z_4)
                        (z_4)   edge [] node {1} (z_5)
                        (z_5)   edge [] node {1} (z_6)
                        (z_6)   edge [] node {1} (z_7)
                        (z_7)   edge [] node {1} (z_8)
                        (z_8)   edge [] node {1} (z_9)
                        (z_9)   edge [] node {1} (z_10)
                        (z_10)  edge [] node {1} (z_11)
                        (z_11)  edge [] node {1} (z_12)
                        (z_12)  edge [] node {1} (z_13)
                        (z_13)  edge [] node {1} (z_14)
                        (z_14)  edge [bend left] node {1} (z_0)
                    ;
                \end{tikzpicture}
              \end{figure}
        \item For \(M = (Z, A, \delta, z_s, Z_A)\) assuming that \(A_1 = A_2\) for both languages
              \begin{displaymath}
                \begin{aligned}
                    Z &= Z_1 \times Z_2 \\
                    A &= A_1 = A_2 \\
                    \delta((z_1, z_2), x) &= (\delta_1(z_1, x), \delta_2(z_2, x)) \\
                    z_s &= (z_{1_s}, z_{2_s}) \\
                    % Z_A &= \{(z_1, z_2) : z_1 \in Z_{1_A}, z_2 \in Z_2 \lor z_1 \in Z_1, z_2 \in Z_{2_A} \}
                    Z_A &= (Z_{1_A} \times Z_2) \cup (Z_1 \times Z_{2_A})
                \end{aligned}
              \end{displaymath}
        \end{enumerate}
    \end{tasks}
\end{document}